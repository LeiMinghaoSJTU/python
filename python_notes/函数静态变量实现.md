在 Python 中，**函数本身没有像其他语言（如 C/C++、Java）那样专门的“静态变量”语法**，但可以通过一些技巧实现类似的功能——即让变量在函数多次调用之间保持状态（不被重新初始化）。


### 常见实现方式
#### 1. 函数属性（最直接的方式）
Python 中函数是一等公民（可以像对象一样拥有属性），因此可以给函数绑定一个属性来模拟静态变量。

```python
def count_calls():
    # 第一次调用时初始化属性
    if not hasattr(count_calls, "counter"): # hasattr即has attribution，检查对象是否有某属性
        count_calls.counter = 0  # 给函数绑定一个counter属性
    count_calls.counter += 1
    print(f"函数被调用了 {count_calls.counter} 次")

# 测试
count_calls()  # 输出：函数被调用了 1 次
count_calls()  # 输出：函数被调用了 2 次
count_calls()  # 输出：函数被调用了 3 次
```

**原理**：函数对象本身存储属性，多次调用时共享同一个属性值，实现状态保持。


#### 2. 闭包（更封装的方式）
通过外层函数定义变量，内层函数引用并修改该变量，形成闭包来保存状态。

```python
def outer_func():
    # 这个变量会在inner_func多次调用间保持状态
    static_var = 0
    
    def inner_func():
        nonlocal static_var  # 声明为非局部变量，允许修改外层变量
        static_var += 1
        print(f"静态变量值：{static_var}")
    
    return inner_func

# 创建闭包实例
func = outer_func()

# 测试
func()  # 输出：静态变量值：1
func()  # 输出：静态变量值：2
func()  # 输出：静态变量值：3
```

**特点**：变量`static_var`被封装在闭包内部，不会污染全局命名空间，比函数属性更隐蔽。


#### 3. 使用装饰器（适合复用逻辑）
如果多个函数都需要“静态变量”功能，可以用装饰器封装逻辑，实现代码复用。

```python
def static_var_decorator(initial_value):
    def decorator(func):
        func.static_var = initial_value  # 给函数绑定初始值
        return func
    return decorator

# 使用装饰器定义带静态变量的函数
@static_var_decorator(0)  # 初始值为0
def increment():
    increment.static_var += 1
    print(f"当前值：{increment.static_var}")

# 测试
increment()  # 输出：当前值：1
increment()  # 输出：当前值：2
```


#### 4. 全局变量（不推荐）
也可以用全局变量实现状态保持，但会污染全局命名空间，且不符合函数封装的原则，不推荐。

```python
global_var = 0  # 全局变量模拟静态变量

def func():
    global global_var  # 声明使用全局变量
    global_var += 1
    print(f"全局变量值：{global_var}")

func()  # 输出：全局变量值：1
func()  # 输出：全局变量值：2
```


### 总结
Python 没有专门的函数静态变量语法，但通过**函数属性**、**闭包**或**装饰器**可以优雅地模拟其功能，其中：
- 函数属性最简单直观，适合单个函数的简单需求；
- 闭包更注重封装，适合需要隐藏变量的场景；
- 装饰器适合多个函数复用“静态变量”逻辑。

这些方法的核心都是让变量脱离函数调用的局部作用域，在多次调用之间保持状态。
