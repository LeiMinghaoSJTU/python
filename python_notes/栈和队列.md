在Python中，栈（Stack）和队列（Queue）是两种常用的线性数据结构，它们的核心区别在于元素的存取顺序不同，适用于不同的场景。


### **一、栈（Stack）**
栈是一种遵循**后进先出（LIFO，Last In First Out）** 原则的数据结构：最后加入的元素最先被取出，最先进来的元素最后被取出。

#### **核心操作**
- **入栈（Push）**：向栈顶添加元素。
- **出栈（Pop）**：从栈顶移除并返回元素。
- **查看栈顶（Peek）**：返回栈顶元素但不移除。
- **判断为空（Is Empty）**：检查栈是否没有元素。


#### **Python中实现栈的方式**
##### 1. 列表（List）实现（最简单）
Python的内置列表（list）天然支持栈的操作，通过`append()`（入栈）和`pop()`（出栈）方法即可实现，时间复杂度均为O(1)。

```python
# 用列表实现栈
stack = []

# 入栈
stack.append(1)  # stack: [1]
stack.append(2)  # stack: [1, 2]
stack.append(3)  # stack: [1, 2, 3]

# 出栈（移除并返回栈顶元素）
print(stack.pop())  # 输出: 3，stack变为 [1, 2]

# 查看栈顶元素
print(stack[-1])  # 输出: 2（栈顶是最后加入的元素）

# 判断是否为空
print(len(stack) == 0)  # 输出: False
```


##### 2. `collections.deque`实现（更高效）
`deque`（双端队列）是Python标准库`collections`中的结构，其`append()`和`pop()`操作效率比列表更高（尤其数据量大时），因为列表在极端情况下可能需要重新分配内存，而`deque`是为频繁的两端操作设计的。

```python
from collections import deque

# 用deque实现栈
stack = deque()

# 入栈
stack.append(1)
stack.append(2)
stack.append(3)

# 出栈
print(stack.pop())  # 输出: 3

# 查看栈顶
print(stack[-1])  # 输出: 2

# 判断为空
print(len(stack) == 0)  # 输出: False
```


#### **栈的应用场景**
- 括号匹配校验（如判断`((()))`是否合法）。
- 函数调用栈（程序执行时的函数调用顺序）。
- 撤销操作（如文本编辑器的“Ctrl+Z”）。


### **二、队列（Queue）**
队列是一种遵循**先进先出（FIFO，First In First Out）** 原则的数据结构：最先加入的元素最先被取出，最后加入的元素最后被取出。

#### **核心操作**
- **入队（Enqueue）**：向队尾添加元素。
- **出队（Dequeue）**：从队头移除并返回元素。
- **查看队头（Peek）**：返回队头元素但不移除。
- **判断为空（Is Empty）**：检查队列是否没有元素。


#### **Python中实现队列的方式**
##### 1. 避免用列表实现队列
列表虽然可以用`append()`（入队）和`pop(0)`（出队）模拟队列，但`pop(0)`需要将所有元素向前移动一位，时间复杂度为O(n)，数据量大时效率极低，因此**不推荐**。

```python
# 不推荐：用列表实现队列（效率低）
queue = []

# 入队
queue.append(1)  # queue: [1]
queue.append(2)  # queue: [1, 2]
queue.append(3)  # queue: [1, 2, 3]

# 出队（移除并返回队头元素）
print(queue.pop(0))  # 输出: 1，queue变为 [2, 3]（效率低）
```


##### 2. `collections.deque`实现（推荐）
`deque`的`append()`（入队）和`popleft()`（出队）操作均为O(1)时间复杂度，是实现队列的最佳选择。

```python
from collections import deque

# 用deque实现队列
queue = deque()

# 入队
queue.append(1)
queue.append(2)
queue.append(3)

# 出队
print(queue.popleft())  # 输出: 1，queue变为 deque([2, 3])

# 查看队头
print(queue[0])  # 输出: 2

# 判断为空
print(len(queue) == 0)  # 输出: False
```


##### 3. `queue.Queue`实现（线程安全）
如果需要在多线程环境中使用队列（如任务调度），可以用标准库`queue`中的`Queue`类，它自带线程锁，保证多线程安全。

```python
from queue import Queue

# 用Queue实现队列（线程安全）
q = Queue()

# 入队
q.put(1)
q.put(2)
q.put(3)

# 出队
print(q.get())  # 输出: 1（若队列为空，get()会阻塞等待）

# 查看队列大小
print(q.qsize())  # 输出: 2

# 判断为空
print(q.empty())  # 输出: False
```


#### **队列的应用场景**
- 任务调度（如打印队列、多线程任务分配）。
- 广度优先搜索（BFS，遍历树或图时按层次访问节点）。
- 缓冲机制（如网络数据传输中的数据缓冲）。


### **总结**
| 数据结构 | 核心原则         | Python推荐实现                                         | 核心操作                                                    | 适用场景                |
| -------- | ---------------- | ------------------------------------------------------ | ----------------------------------------------------------- | ----------------------- |
| 栈       | 后进先出（LIFO） | `collections.deque`                                    | `append()`、`pop()`                                         | 括号匹配、撤销操作      |
| 队列     | 先进先出（FIFO） | `collections.deque`（单线程）、`queue.Queue`（多线程） | `append()`、`popleft()`（deque）；`put()`、`get()`（Queue） | 任务调度、BFS、缓冲机制 |

实际开发中，优先使用`deque`实现栈和队列（高效），多线程场景下使用`queue.Queue`。