在Python中，链表（Linked List）是一种常见的线性数据结构，它由一系列节点（Node）组成，每个节点包含两部分：**数据域**（存储数据）和**指针域**（存储下一个节点的引用）。与Python内置的列表（List）不同，链表的元素在内存中不是连续存储的，这使得它在插入、删除操作上具有独特的优势。


### 一、链表的基本结构
链表的核心是**节点（Node）**，一个简单的节点结构如下：
- 数据域（data）：存储具体的数据（如整数、字符串等）
- 指针域（next）：存储下一个节点的引用（类似"指针"，指向链表中的下一个元素）

最基础的链表是**单链表**，其结构示意图如下：
```
头节点 → 节点1(data: A, next: 节点2) → 节点2(data: B, next: 节点3) → 节点3(data: C, next: None)
```
- 头节点（head）：链表的起始节点，用于定位整个链表
- 尾节点：最后一个节点，其`next`为`None`（表示链表结束）


### 二、链表与列表（List）的对比
| 操作               | 链表（平均情况）   | 列表（平均情况） | 说明                               |
| ------------------ | ------------------ | ---------------- | ---------------------------------- |
| 随机访问（按索引） | O(n)               | O(1)             | 链表需从头遍历，列表直接定位       |
| 头部插入/删除      | O(1)               | O(n)             | 列表需移动后续所有元素             |
| 中间插入/删除      | O(n)               | O(n)             | 均需先定位位置，但链表无需移动元素 |
| 内存占用           | 较高（需存储指针） | 较低             | 链表额外存储指针信息               |


### 三、Python实现单链表
Python中没有内置链表类型，需手动定义节点和链表类。下面是单链表的基本实现：


#### 1. 定义节点类（Node）
```python
class Node:
    def __init__(self, data):
        self.data = data  # 数据域
        self.next = None  # 指针域，初始指向None
```


#### 2. 定义单链表类（LinkedList）
链表类通常包含以下核心操作：
- 初始化链表
- 头部插入节点
- 尾部插入节点
- 指定位置插入节点
- 删除指定节点
- 遍历链表
- 查找节点


```python
class LinkedList:
    def __init__(self):
        self.head = None  # 头节点初始为None（空链表）

    # 头部插入节点
    def add_at_head(self, data):
        new_node = Node(data)  # 创建新节点
        new_node.next = self.head  # 新节点的next指向原头节点
        self.head = new_node  # 更新头节点为新节点

    # 尾部插入节点
    def add_at_tail(self, data):
        new_node = Node(data)
        if self.head is None:  # 空链表时，新节点直接作为头节点
            self.head = new_node
            return
        # 非空链表：从头遍历到尾节点
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node  # 尾节点的next指向新节点

    # 在指定索引位置插入节点（索引从0开始）
    def add_at_index(self, index, data):
        if index < 0:
            print("索引不能为负数")
            return
        # 索引为0时，等价于头部插入
        if index == 0:
            self.add_at_head(data)
            return
        # 查找索引位置的前一个节点
        current = self.head
        prev = None
        count = 0
        while current and count < index:
            prev = current
            current = current.next
            count += 1
        # 若索引超出链表长度，无法插入
        if count < index:
            print("索引超出链表长度")
            return
        # 插入新节点
        new_node = Node(data)
        prev.next = new_node
        new_node.next = current

    # 删除指定值的第一个节点
    def delete_by_value(self, value):
        if self.head is None:  # 空链表
            print("链表为空，无法删除")
            return
        # 若头节点就是要删除的节点
        if self.head.data == value:
            self.head = self.head.next
            return
        # 查找要删除节点的前一个节点
        current = self.head
        prev = None
        while current and current.data != value:
            prev = current
            current = current.next
        # 若未找到该节点
        if current is None:
            print(f"未找到值为{value}的节点")
            return
        # 删除节点（跳过当前节点）
        prev.next = current.next

    # 遍历链表并打印所有元素
    def traverse(self):
        current = self.head
        result = []
        while current:
            result.append(str(current.data))
            current = current.next
        print(" → ".join(result) + " → None")

    # 查找指定值的节点是否存在
    def search(self, value):
        current = self.head
        index = 0
        while current:
            if current.data == value:
                return index  # 返回找到的索引
            current = current.next
            index += 1
        return -1  # 未找到返回-1
```


### 四、使用示例
```python
# 创建链表
linked_list = LinkedList()

# 尾部插入元素
linked_list.add_at_tail(10)
linked_list.add_at_tail(20)
linked_list.add_at_tail(30)
linked_list.traverse()  # 输出：10 → 20 → 30 → None

# 头部插入元素
linked_list.add_at_head(5)
linked_list.traverse()  # 输出：5 → 10 → 20 → 30 → None

# 指定位置插入元素（索引2处插入15）
linked_list.add_at_index(2, 15)
linked_list.traverse()  # 输出：5 → 10 → 15 → 20 → 30 → None

# 查找元素
print(linked_list.search(20))  # 输出：3（20在索引3处）

# 删除元素
linked_list.delete_by_value(15)
linked_list.traverse()  # 输出：5 → 10 → 20 → 30 → None
```


### 五、常见链表变种
1. **双向链表**：每个节点除了`next`，还有`prev`指针指向前一个节点，支持双向遍历，插入删除更灵活，但内存占用更高。
   
2. **循环链表**：尾节点的`next`指向头节点，形成环形结构，适合需要循环访问的场景（如约瑟夫问题）。


### 六、应用场景
- 实现栈、队列等数据结构（链表的头部/尾部操作效率高）
- 哈希表解决哈希冲突（链地址法）
- 频繁插入/删除操作的场景（如链表式编辑器）

通过链表的实现和使用，可以更深入理解线性数据结构的设计思想，以及不同结构在性能上的权衡。