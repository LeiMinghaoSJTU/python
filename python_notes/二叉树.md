要理解Python中的二叉树，我们需要从**基本概念**、**数据结构实现**、**核心遍历算法**、**常见操作**到**实际应用**逐步拆解。二叉树是一种非线性数据结构，每个节点最多有两个子节点（左子节点和右子节点），是树结构中最基础也最常用的类型。


## 一、二叉树的基本概念
在深入代码前，先明确二叉树的核心术语和分类，这是理解后续操作的基础。

### 1. 核心术语
- **节点（Node）**：二叉树的基本单元，包含三个要素：
  - `val`：节点存储的值（如整数、字符串等）。
  - `left`：指向左子节点的引用（初始为`None`，表示无左子节点）。
  - `right`：指向右子节点的引用（初始为`None`，表示无右子节点）。
- **根节点（Root）**：二叉树的顶层节点，没有父节点。
- **叶子节点（Leaf）**：没有左、右子节点的节点（`left`和`right`均为`None`）。
- **子树（Subtree）**：以某个节点为根的局部二叉树（左子树=根的左节点及其后代，右子树同理）。
- **深度（Depth）**：从**根节点**到当前节点的边数（根节点深度为0，其子节点深度为1）。
- **高度（Height）**：从当前节点到**最远叶子节点**的边数（叶子节点高度为0，根节点高度=树的总高度）。


### 2. 常见二叉树分类
不同类型的二叉树有特殊性质，决定了其适用场景：

| 类型              | 定义                                                                        | 应用场景                            |
| ----------------- | --------------------------------------------------------------------------- | ----------------------------------- |
| 普通二叉树        | 无特殊限制，每个节点最多2个子节点                                           | 基础结构，用于理解树的特性          |
| 满二叉树          | 所有叶子节点在同一层，且非叶子节点均有2个子节点                             | 完全二叉树的特殊情况                |
| 完全二叉树        | 按层序遍历（从左到右、从上到下），空节点只允许出现在最后一层的右侧          | 堆（Heap）的底层实现                |
| 二叉搜索树（BST） | 左子树所有节点值 < 根节点值；右子树所有节点值 > 根节点值（左右子树也为BST） | 高效查找、插入、删除（平均O(logn)） |


## 二、Python实现二叉树的基础结构
Python中没有内置二叉树，需通过**类（Class）** 定义节点，再基于节点构建树。


### 1. 定义节点类（TreeNode）
首先实现一个`TreeNode`类，封装节点的`val`、`left`、`right`三个属性：
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        """
        初始化二叉树节点
        :param val: 节点存储的值（默认0）
        :param left: 左子节点（默认None）
        :param right: 右子节点（默认None）
        """
        self.val = val
        self.left = left
        self.right = right
```


### 2. 手动构建一棵简单二叉树
通过实例化`TreeNode`，手动连接节点，构建一棵如下结构的二叉树：
```
    1
   / \
  2   3
 / \
4   5
```

代码实现：
```python
# 构建叶子节点
node4 = TreeNode(4)
node5 = TreeNode(5)
node3 = TreeNode(3)

# 构建中间节点
node2 = TreeNode(2, left=node4, right=node5)

# 构建根节点（整棵树的入口）
root = TreeNode(1, left=node2, right=node3)
```

此时，`root`就是整棵树的入口，通过`root.left`可访问左子树（节点2），通过`root.right`可访问右子树（节点3）。


## 三、二叉树的核心遍历算法
遍历是二叉树最基础的操作，目的是按某种顺序访问所有节点。根据访问顺序的不同，分为**深度优先遍历（DFS）** 和**广度优先遍历（BFS）**，其中DFS又细分为前序、中序、后序三种。


### 1. 深度优先遍历（DFS）
DFS基于“先深后广”的原则，通过**递归**或**栈（Stack）** 实现（递归本质是调用栈）。三种遍历的区别在于**根节点的访问时机**。

#### （1）前序遍历（Pre-order）：根 → 左 → 右
- 逻辑：先访问当前节点，再递归遍历左子树，最后递归遍历右子树。
- 示例（上文树）：`1 → 2 → 4 → 5 → 3`

**递归实现**（简单直观，适合理解）：
```python
def preorder_traversal(root: TreeNode) -> list:
    """前序遍历：根→左→右，返回遍历结果列表"""
    result = []
    if root:
        # 1. 访问根节点
        result.append(root.val) # 这是列表的append方法，意思是把当前节点值加入结果列表的末尾
        # 2. 递归遍历左子树
        result.extend(preorder_traversal(root.left)) # 这是列表的extend方法，意思是把左子树遍历结果列表的所有元素加入结果列表的末尾
        # 3. 递归遍历右子树
        result.extend(preorder_traversal(root.right))
    return result

# 测试
print(preorder_traversal(root))  # 输出：[1, 2, 4, 5, 3]
```

**迭代实现**（用栈模拟递归，避免递归栈溢出）：
```python
def preorder_traversal_iter(root: TreeNode) -> list:
    result = []
    if not root:
        return result
    stack = [root]  # 栈初始化，存入根节点
    while stack:
        node = stack.pop()  # 弹出栈顶节点（先入后出）
        result.append(node.val)  # 1. 访问根节点
        # 2. 压入右子节点（栈先入后出，需先压右再压左）
        if node.right:
            stack.append(node.right)
        # 3. 压入左子节点
        if node.left:
            stack.append(node.left)
    return result

print(preorder_traversal_iter(root))  # 输出：[1, 2, 4, 5, 3]
```


#### （2）中序遍历（In-order）：左 → 根 → 右
- 逻辑：先递归遍历左子树，再访问当前节点，最后递归遍历右子树。
- 关键特性：**二叉搜索树（BST）的中序遍历结果是升序序列**（核心应用）。
- 示例（上文树）：`4 → 2 → 5 → 1 → 3`

**递归实现**：
```python
def inorder_traversal(root: TreeNode) -> list:
    result = []
    if root:
        # 1. 递归遍历左子树
        result.extend(inorder_traversal(root.left))
        # 2. 访问根节点
        result.append(root.val)
        # 3. 递归遍历右子树
        result.extend(inorder_traversal(root.right))
    return result

print(inorder_traversal(root))  # 输出：[4, 2, 5, 1, 3]
```

**迭代实现**（需先压完所有左节点）：
```python
def inorder_traversal_iter(root: TreeNode) -> list:
    result = []
    stack = []
    current = root
    while current or stack:
        # 1. 先将当前节点的所有左子节点压入栈
        while current:
            stack.append(current)
            current = current.left
        # 2. 弹出栈顶节点（左子树已遍历完），访问根节点
        node = stack.pop()
        result.append(node.val)
        # 3. 遍历右子树
        current = node.right
    return result

print(inorder_traversal_iter(root))  # 输出：[4, 2, 5, 1, 3]
```


#### （3）后序遍历（Post-order）：左 → 右 → 根
- 逻辑：先递归遍历左子树，再递归遍历右子树，最后访问当前节点。
- 示例（上文树）：`4 → 5 → 2 → 3 → 1`

**递归实现**：
```python
def postorder_traversal(root: TreeNode) -> list:
    result = []
    if root:
        # 1. 递归遍历左子树
        result.extend(postorder_traversal(root.left))
        # 2. 递归遍历右子树
        result.extend(postorder_traversal(root.right))
        # 3. 访问根节点
        result.append(root.val)
    return result

print(postorder_traversal(root))  # 输出：[4, 5, 2, 3, 1]
```

**迭代实现**（需标记节点是否已处理，常用“栈+标记”法）：
```python
def postorder_traversal_iter(root: TreeNode) -> list:
    result = []
    if not root:
        return result
    # 栈元素：(节点, 是否已处理)，False=未处理，True=已处理
    stack = [(root, False)]
    while stack:
        node, is_processed = stack.pop()
        if is_processed:
            # 已处理：访问根节点（左、右子树已遍历完）
            result.append(node.val)
        else:
            # 未处理：标记为已处理，再压入右、左子节点（顺序：根→右→左，弹出时左→右→根）
            stack.append((node, True))
            if node.right:
                stack.append((node.right, False))
            if node.left:
                stack.append((node.left, False))
    return result

print(postorder_traversal_iter(root))  # 输出：[4, 5, 2, 3, 1]
```


### 2. 广度优先遍历（BFS）：层序遍历
BFS基于“先广后深”的原则，按**层**访问节点（从上到下、从左到右），通过**队列（Queue）** 实现（队列先进先出，保证层序顺序）。

- 示例（上文树）：`1 → 2 → 3 → 4 → 5`

**迭代实现**（Python用`deque`实现队列，效率更高）：
```python
from collections import deque

def levelorder_traversal(root: TreeNode) -> list:
    result = []
    if not root:
        return result
    queue = deque([root])  # 队列初始化，存入根节点
    while queue:
        level_size = len(queue)  # 当前层的节点数
        current_level = []  # 存储当前层的节点值
        for _ in range(level_size):
            node = queue.popleft()  # 弹出队首节点（先进先出）
            current_level.append(node.val)
            # 压入左子节点（下一层）
            if node.left:
                queue.append(node.left)
            # 压入右子节点（下一层）
            if node.right:
                queue.append(node.right)
        result.append(current_level)  # 将当前层加入结果
    return result

print(levelorder_traversal(root))  # 输出：[[1], [2, 3], [4, 5]]（按层分组）
```


## 四、二叉树的常见操作
除了遍历，二叉树的核心操作还包括**求高度、求节点数、查找值、插入节点、删除节点**（以二叉搜索树BST为例，因为普通二叉树的插入/删除无固定规则）。


### 1. 求二叉树的高度
- 逻辑：树的高度 = 1 + max(左子树高度, 右子树高度)（空树高度为-1或0，需统一定义）。

**递归实现**：
```python
def tree_height(root: TreeNode) -> int:
    """求树的高度（空树返回-1，叶子节点返回0）"""
    if not root:
        return -1  # 若空树返回0，则叶子节点返回1，需根据需求调整
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)
    return 1 + max(left_height, right_height)

print(tree_height(root))  # 上文树高度：2（根1→子2→叶4，共2条边）
```

**迭代实现**（基于层序遍历，层数即高度）：
```python
def tree_height_iter(root: TreeNode) -> int:
    if not root:
        return -1
    queue = deque([root])
    height = -1
    while queue:
        level_size = len(queue)
        height += 1  # 每遍历一层，高度+1
        for _ in range(level_size):
            node = queue.popleft()
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    return height

print(tree_height_iter(root))  # 输出：2
```


### 2. 求二叉树的节点总数
- 逻辑：总节点数 = 1 + 左子树节点数 + 右子树节点数。

**递归实现**：
```python
def count_nodes(root: TreeNode) -> int:
    if not root:
        return 0
    return 1 + count_nodes(root.left) + count_nodes(root.right)

print(count_nodes(root))  # 上文树节点数：5
```


### 3. 二叉搜索树（BST）的查找、插入、删除
BST的有序性（左<根<右）让查找、插入、删除操作效率更高（平均时间复杂度O(logn)），以下实现BST的核心操作。

#### （1）BST查找值
- 逻辑：若当前节点值 == 目标值，返回True；若目标值 < 当前节点值，递归左子树；否则递归右子树。

```python
def bst_search(root: TreeNode, target: int) -> bool:
    if not root:
        return False  # 空树，未找到
    if root.val == target:
        return True  # 找到目标值
    elif target < root.val:
        return bst_search(root.left, target)  # 左子树查找
    else:
        return bst_search(root.right, target)  # 右子树查找

# 测试：查找4（存在）和6（不存在）
print(bst_search(root, 4))  # 输出：True
print(bst_search(root, 6))  # 输出：False
```


#### （2）BST插入节点
- 逻辑：新节点始终作为叶子节点插入。若目标值 < 当前节点值，左子树为空则插入左，否则递归左子树；反之递归右子树。

```python
def bst_insert(root: TreeNode, val: int) -> TreeNode:
    """插入节点，返回新的根节点（处理空树情况）"""
    if not root:
        return TreeNode(val)  # 空树，新节点为根
    if val < root.val:
        root.left = bst_insert(root.left, val)  # 插入左子树
    else:
        root.right = bst_insert(root.right, val)  # 插入右子树
    return root

# 测试：插入6到BST中
new_root = bst_insert(root, 6)
print(inorder_traversal(new_root))  # 输出：[4,2,5,1,3,6]（升序验证BST）
```


#### （3）BST删除节点（最复杂）
删除需分三种情况，核心是**保持BST的有序性**：
1. **叶子节点**：直接删除（置为None）。
2. **只有一个子节点**：用子节点替换当前节点。
3. **有两个子节点**：用**中序后继**（右子树的最小节点）或**中序前驱**（左子树的最大节点）替换当前节点，再删除后继/前驱。

```python
def find_min_node(node: TreeNode) -> TreeNode:
    """找到BST中最小节点（最左节点），用于获取中序后继"""
    current = node
    while current.left:
        current = current.left
    return current

def bst_delete(root: TreeNode, val: int) -> TreeNode:
    """删除值为val的节点，返回新的根节点"""
    if not root:
        return root  # 空树，无需删除
    
    # 1. 找到要删除的节点
    if val < root.val:
        root.left = bst_delete(root.left, val)  # 左子树删除
    elif val > root.val:
        root.right = bst_delete(root.right, val)  # 右子树删除
    else:
        # 2. 找到目标节点，处理三种删除情况
        # 情况1：叶子节点或只有一个右子节点
        if not root.left:
            return root.right  # 用右子节点替换
        # 情况2：只有一个左子节点
        elif not root.right:
            return root.left  # 用左子节点替换
        # 情况3：有两个子节点，找中序后继（右子树最小节点）
        successor = find_min_node(root.right)
        root.val = successor.val  # 用后继值替换当前节点值
        root.right = bst_delete(root.right, successor.val)  # 删除后继节点
    
    return root

# 测试：删除根节点1（有两个子节点）
deleted_root = bst_delete(new_root, 1)
print(inorder_traversal(deleted_root))  # 输出：[4,2,5,3,6]（仍为升序）
```


## 五、二叉树的应用场景
1. **排序与搜索**：二叉搜索树（BST）的中序遍历是升序序列，支持高效查找/插入/删除。
2. **堆排序**：完全二叉树的结构适合实现堆（大根堆/小根堆），用于Top-K问题。
3. **表达式树**：用于解析数学表达式（如`(3+4)*5`，根为`*`，左子树为`+`，右子树为`5`）。
4. **哈夫曼编码**：基于哈夫曼树（带权路径最短的二叉树）实现数据压缩。
5. **数据库索引**：B树、B+树（基于二叉树的扩展）是数据库索引的核心结构。


## 六、总结
- **基础**：二叉树由节点构成，每个节点最多2个子节点，核心是“左”和“右”的区分。
- **遍历**：DFS（前/中/后序）和BFS（层序）是核心，递归易理解，迭代需用栈/队列模拟。
- **BST**：有序性是关键，支持高效操作，删除节点需处理三种情况。
- **应用**：从排序到数据库索引，二叉树是复杂数据结构的基础。

掌握二叉树后，可进一步学习**平衡二叉树（AVL）**、**红黑树**、**堆**等进阶结构，它们在实际工程中（如Python的`heapq`模块、数据库索引）应用广泛。