# 基于双线性变换的 IIR（Butterworth）低通滤波器设计说明

> 本文档详细解释使用“模拟 Butterworth 原型 + 预加重 + 双线性变换（Bilinear Transform）”来设计数字无限冲激响应（IIR）低通滤波器的每一步思路、数学依据、实现要点与注意事项，并给出可运行的示例代码与若干改进建议。

---

## 1. 设计目标与问题陈述

给定采样率 $fs$ 和期望数字域截止频率 $fc$（Hz），以及设计阶数 $N$（或按规范求最小阶数），目标是得到数字 IIR 低通滤波器的差分方程（或传递函数系数 $b$, $a$），使其在数字域对低于 $fc$ 的频率保留（通带），对高于 $fc$ 的频率衰减（阻带），并尽量满足稳定性与数值稳定实现的要求。

为什么要从模拟原型出发？因为经典模拟滤波器（Butterworth、Chebyshev、Elliptic）具有明确的极点布局与良好的人类可理解性。双线性变换给出了一种把模拟域（s 域）映射到数字域（z 域）的保稳定、保单调映射手段。

---

## 2. 设计流程总览

1. 确定规格：采样率 $fs$、数字截止频率 $fc$、滤波器阶数 $N$（或由通/阻带规格计算阶数）。
2. 预加重（pre-warp）：把数字域截止 $\omega_d$（弧度/采样或 Hz）映射到模拟域的角频 $\Omega_c$，补偿双线性变换的频率扭曲。
3. 设计模拟 Butterworth 原型：得到模拟原型的极点 $p_i$ 与增益 $k$（buttap/N）。
4. 按 $\Omega_c$ 缩放模拟极点（和增益）得到期望模拟系统的极点与增益（以满足模拟截止）。
5. 对模拟传递函数做双线性变换（s -> 2*fs*(1 - z^{-1})/(1 + z^{-1})）得到数字零/极/增益（zpk）。
6. 将 zpk 转成传递函数系数 $b, a$，并（可选）转换为二阶节（sos）以提高数值稳定性。
7. 验证：绘制频率响应、群时延、对试验信号滤波并分析时域/频域效果。

---

## 3. 每一步的详细解释与数学推导

### 3.1 双线性变换及预加重（为什么要做）

**双线性变换（Bilinear Transform）** 将模拟复平面 s 映射到数字复平面 z：

$$
s = \frac{2}{T} \frac{1 - z^{-1}}{1 + z^{-1}} = 2 f_s \frac{1 - z^{-1}}{1 + z^{-1}},
$$

其中 $T = 1/fs$。优点：

* 稳定性映射：模拟左半平面（Re(s) < 0）被映射到单位圆内部（|z| < 1），因此稳定系统保持稳定。
* 无重叠（aliasing）问题（这是不同于经典采样/耦合方法的重要优点）。

缺点：频率会被非线性扭曲（warping）。若我们在模拟域设计截止频率 $\Omega_c$，它在数字域对应的频率 $\omega$（弧度/采样）满足关系：

由映射对单位圆 $z = e^{j\omega}$ 代入上式：

\[
j\Omega = 2 f_s \frac{1 - e^{-j\omega}}{1 + e^{-j\omega}} = 2 f_s j \tan\left(\frac{\omega}{2}\right),\]

从而得到模拟角频率与数字角频率的关系：

\[
\Omega = 2 f_s \tan\left(\frac{\omega}{2}\right).
\]

如果我们希望数字域的截止角频 $\omega_c$ 对应到模拟域的 $\Omega_c$，则需要做 **预加重（pre-warp）**：

$$
\Omega_c = 2 f_s \tan\left(\frac{\omega_c}{2}\right).
$$

若以 Hz 表示数字截止频率 $f_c$，则 $\omega_c = 2\pi f_c / f_s$，代入可得到常用的公式：

$$
\Omega_c = 2 f_s \tan\left(\frac{\pi f_c}{f_s}\right).
$$

**结论**：先按上式把数字截止 $f_c$ 映射到模拟截止 $\Omega_c$，在模拟域设计滤波器，再做双线性变换，这样数字滤波器在 $f_c$ 处的特性更接近期望（即补偿频率扭曲）。

### 3.2 模拟 Butterworth 原型（buttap）

Butterworth 滤波器的定义：在模拟频率轴上其幅度响应在通带尽可能平坦（最大平坦），在幅值平方上为：

$$
|H(j\Omega)|^2 = \frac{1}{1 + (\Omega/\Omega_c)^{2N}}.
$$

Butterworth 的极点位于单位圆上角度均匀分布的左半平面点。$buttap(N)$ 返回归一化（$\Omega_c = 1$）的模拟原型的零、极、增益：通常无零（只有极）、N 个极、增益 $k$。

归一化的好处是我们只需缩放极点到任意 $\Omega_c$ 即可得到目标模拟滤波器。

### 3.3 放缩极点与增益调整

如果原型极点为 $p_i$（对应 $\Omega_c = 1$），则放缩到目标 $\Omega_c$：

$$
\tilde p_i = p_i \cdot \Omega_c.
$$

增益也需要相应放缩，以保持直流增益或规格（对于低通，常把增益按 $k * \Omega_c^N$ 处理，见实现库做法），总体目标是构造模拟传递函数

$$
H_a(s) = k \frac{\prod (s - z_i)}{\prod (s - \tilde p_i)}.
$$

对于 Butterworth，$z_i$ 通常为空（无有限零），因此为纯极形式。

### 3.4 对模拟传递函数做双线性变换（实现细节）

把模拟零极增益 $(z, p, k)$ 作双线性变换可以逐个映射模拟极点到数字极点（并自动产生数字零）。在 SciPy 中可以使用 $bilinear_zpk(z, p, k, fs)$，它会返回对应的数字域 $(z_d, p_d, k_d)$。

映射要点：

* s 域左半平面的极点映射为 z 域内部的极点（稳定性保持）。
* 模拟的无穷远处行为（比如高频处的增益）会影响数字域的零分布。

数学上，双线性变换为有理分式映射，若模拟传递函数为分式多项式，则代换后得到数字传递函数的多项式系数。

### 3.5 转换为差分方程系数（zpk -> tf -> 实现）

$zpk2tf$ 把零/极/增益转换成多项式系数 $b$（分子）与 $a$（分母），形式如下：

$$
H(z) = \frac{b_0 + b_1 z^{-1} + \dots + b_M z^{-M}}{a_0 + a_1 z^{-1} + \dots + a_N z^{-N}}.
$$

然后就可以用 $scipy.signal.lfilter(b, a, x)$ 做实时（逐样本）滤波，或用 $sos$（二阶节）与 $sosfilt$/$sosfiltfilt$ 做更稳定的实现。

### 3.6 数值稳定性与二阶节（SOS）

当滤波器阶数较高时（例如 N >= 6），直接使用多项式系数 $b,a$ 进行滤波可能出现数值不稳定（系数相差很大或极点成对出现导致系数敏感）。解决方法：

* 把高阶滤波器分解为若干个二阶节（Second-Order Sections, SOS），每节实现形式为：

$$
H_{sos}(z)=\prod_{k} \frac{b_{k0} + b_{k1} z^{-1} + b_{k2} z^{-2}}{a_{k0} + a_{k1} z^{-1} + a_{k2} z^{-2}}.
$$

* SciPy 中可以用 $scipy.signal.zpk2sos$ 或 $tf2sos$ 来得到 SOS，然后用 $sosfilt$ 或 $sosfiltfilt$ 来过滤。$filtfilt$/$sosfiltfilt$ 可以实现零相位响应（双向滤波），但会改变滤波器的因果性（常用于离线处理）。

建议：若 N > 4，优先使用 SOS 实现以避免舍入误差和数值不稳定。

### 3.7 验证与测试

常用的验证项目：

* 频率响应（幅度、相位）$freqz$。
* 群时延（group delay）查看相位畸变。
* 单位脉冲响应（impulse response）以验证 IIR 的指数衰减与稳定性。
* 使用含低频与高频分量的合成信号（并加入噪声）观察滤波前后时域与频域（FFT）变化。

尤其注意检查 $fc$ 处是否接近 3 dB 截止点（若以 Butterworth 的定义为准），以及阻带抑制是否满足要求。

### 3.8 参数选择建议

* 阶数 $N$：越高通带越平、过渡带越陡，但数值问题与相位畸变也越明显。工程上常取 2\~6 之间。
* 截止 $fc$：离奈奎斯特频率（$fs/2$）太近会使预加重值 $Omega_c$ 很大，映射之后性能变差并容易数值不良。
* 若需要在给定通带/阻带衰减下自动计算最小阶数，可以使用模拟设计方法（计算模拟域的 $\Omega_p$, $\Omega_s$）然后求阶数，再用双线性变换实现。
* 考虑替代滤波器类型：若对阻带衰减有强要求，可以选择 Chebyshev 或 Elliptic，它们在相同阶数下提供更陡的滚降，但会引入通带纹波或相位问题。

### 3.9 常见陷阱与注意事项

* 忘记做预加重：会导致数字截止频率偏移、性能不达标。
* 直接用高阶 $b,a$ 数组过滤而不采用 SOS：可能出现稳定性问题或舍入误差。
* 截止太接近 Nyquist：频率扭曲严重、数值不稳定。
* 不检查相位/群时延：若是实时控制系统，相位延迟可能破坏系统性能。

## 4. 示例代码（参考实现）

下面给出一个完整可运行示例（Python / SciPy），该代码实现了前文步骤并演示了设计结果如何验证。你可以把以下代码保存为 $butter_bilinear_example.py$ 并直接运行（需要 $numpy$, $scipy$, $matplotlib$）。

$$$python
# 见之前的完整代码：design_butter_bilinear、测试信号、绘图
# 这里给出一个补充：如何把 zpk 转为 sos 并用 filtfilt 零相位滤波

from scipy.signal import zpk2sos, sosfiltfilt

# 假设我们已经得到了 z, p, k（或 zd, pd, kd 从 bilinear_zpk）
# 可以通过 zpk2sos 得到二阶节（有助于数值稳定）

# 示例（如果你用上面的 design_butter_bilinear 返回 b,a）：
# b, a = design_butter_bilinear(N, fc, fs)
# 或者直接从 zpk 得到 sos：
# zd, pd, kd = bilinear_zpk(z, p, k, fs)
# sos = zpk2sos(zd, pd, kd)

# 使用 sosfiltfilt (零相位，离线用)
# y_zero_phase = sosfiltfilt(sos, x)
$$$

## 5. 进阶与扩展建议

* **自动阶数求解**：若给出通带/阻带边界和衰减规格，可先把规格映射到模拟域（用 pre-warp），然后求最小 $N$ 满足模拟域的 Butterworth 阶数公式，再完成后续步骤。
* **多种滤波器类型比较**：如果你需要更好的阻带抑制或更窄的过渡带，可以尝试 Chebyshev I/II 或 Elliptic 并比较相位/群时延代价。
* **固定点实现/滤波器量化**：若要在硬件上实现（定点），需要对系数量化和量化噪声做额外分析，SOS 因为把高阶拆分成 2 阶更易量化。

## 6. 常见问题（FAQ）

**Q：为什么不直接在数字域用 bilinear 设计而不先做模拟原型？**
A：实际上也可以使用数字域直接设计（例如窗口法 FIR、IIR 最小二乘），但经典方法以模拟原型结合双线性变换能快速获得符合经典规格（如 Butterworth 的最大平坦）且数学上直观可解析。

**Q：何时使用 filtfilt？**
A：若你追求零相位失真（例如后处理音频或离线信号处理），可以使用 $filtfilt$ 或 $sosfiltfilt$。注意：这不是实时因果滤波，会在边界引入延拓处理（SciPy 有边界处理策略）。

---

### 附：推荐参考（用于进一步阅读）

* Oppenheim & Schafer, *Discrete-Time Signal Processing*（数字信号处理经典教材）— 详述双线性变换、模拟原型与数字滤波设计。
* Filter design sections in SciPy docs ($scipy.signal$)：具体函数说明和使用示例。

---

如果你需要，我可以：

* 把本 Markdown 导出为 $.md$ 文件供你下载；
* 在文档中加入更完整的代码（例如自动阶数计算、SOS 实现与比较图）；
* 给出 Chebyshev / Elliptic 的同类实现并比较频率响应与相位响应。

告诉我你希望的下一步。
